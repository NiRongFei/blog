---
title: Vue-cli3项目搭建与配置
date: 2019-02-13
tags:
  - frontend
  - vue
categories:
  - 前端
---

## 自动注册组件

在 `components` 中创建 `index.js`，用来扫描全局组件对象并自动注册

```js
import Vue from 'vue'

// 自动加载 global 目录下的 .js 结尾的文件
const componentsContext = require.context('./global', true, /\.js$/)

componentsContext.keys().forEach(component => {
  const componentConfig = componentsContext(component)
  /**
   * 兼容 import export 和 require module.export 两种规范
   */
  const ctrl = componentConfig.default || componentConfig
  Vue.component(ctrl.name, ctrl)
})
```

最后在 `main.js` 中引入 `import '@/components'` 即可。

## 自动导入路由

```js
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

let routes = []
cosnt routeContext = require.context('./', true, /index\.js$/)
routeContext.keys().forEach(route => {
  if (route.startsWith('./index')) return
  const routeModule = routeContext(route)
  routes = [...routes, ...(routeModule.default || routeModule)]
})

export default new Router({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: routes
})
```

## 路由权限

`vue-router` 提供了非常方便的钩子，可以让我们在做路由跳转的时候统一操作，比如常见的权限验证。

首先，需要在 `src/utils` 下创建 `auth.js`，用于存储 `token`

```js
import Cookies from 'js-cookie'
const TokenKey = 'project-token'

export function getToken() {
  return Cookies.get(TokenKey)
}

export function setToken(token) {
  return Cookies.set(TokenKey, token)
}

export function removeToken() {
  return Cookies.remove(TokenKey)
}
```

在 `src/utils` 下创建 `permission.js`

```js
import store from '@/store'
import router from '@/router'
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'
import { getToken } from './auth'
import { Message } from 'element-ui'
// 路由白名单
const whiteList = ['/login']
router.beforeEach((to, from, next) => {
  NProgress.start()
  if (getToken()) {
    if (to.path === '/login') {
      next({
        path: '/'
      })
      NProgress.done()
    } else {
      // 实时拉取用户的信息
      store
        .dispatch('GetUserInfo')
        .then(res => {
          next()
        })
        .catch(err => {
          store.dispatch('FedLogOut').then(() => {
            Message.error('拉取用户信息失败，请重新登录！' + err)
            next({
              path: '/'
            })
          })
        })
    }
  } else {
    if (whiteList.includes(to.path)) {
      next()
    } else {
      next('/login')
      NProgress.done()
    }
  }
})

router.afterEach(() => {
  NProgress.done()
})
```

## 代码压缩

生产环境下通过插件 uglifyjs-webpack-plugin 对代码进行处理

```js
module.export = {
  configureWebpack: config => {
    if (isProduction) {
      config.plugins.push(
        new UglifyJsPlugin({
          uglifyOptions: {
            warnings: false,
            compress: {
              drop_console: true,
              drop_debugger: true,
              pure_funcs: ['console.log']
            }
          },
          sourceMap: false,
          parallel: true
        })
      )
    }
  }
}
```

## 引用 SVG

首先在 `src/components` 下创建 `SvgIcon.vue`

```js
<template>
  <svg :class="svgClass" aria-hidden="true">
    <use :xlink:href="iconName"></use>
  </svg>
</template>

<script lang="ts">
import { Component, Vue, Prop } from 'vue-property-decorator'

@Component({
  name: 'SvgIcon'
})
export default class extends Vue {
  @Prop({ required: true }) private icon!: string
  @Prop({ default: '' }) private className!: string

  get iconName() {
    return `#icon-${this.icon}`
  }

  get svgClass() {
    if (this.className) {
      return 'svg-icon ' + this.className
    } else {
      return 'svg-icon'
    }
  }
}
</script>

<style lang="scss" scoped>
.svg-icon {
  overflow: hidden;
  fill: currentColor;
}
</style>
```

在 `src` 下创建 `icons` 文件夹，并在内部创建 `svg` 文件夹用于存放 `svg` 图标，创建 `index.js` 作为入口文件

```js
import Vue from 'vue'
import SvgIcon from '@/components/SvgIcon.vue'

Vue.component('svg-icon', SvgIcon)

const svgContext = require.context('./svg', false, /\.svg$/)
const svgIcon = context => context.keys().map(context)
svgIcon(svgContext)
```

通过 `svg-sprite-loader` 对项目中使用的 `svg` 进行处理

```js
const path = require('path')

function resolve(dir) {
  return path.join(__dirname, './', dir)
}

module.exports = {
  chainWebpack: config => {
    // 配置SVG
    config.module
      .rule('svg')
      .exclude.add(resolve('src/icons'))
      .end()
    config.module
      .rule('icons')
      .test(/\.svg$/)
      .include.add(resolve('src/icons'))
      .end()
      .use('svg-sprite-loader')
      .loader('svg-sprite-loader')
      .options({
        symbolId: 'icon-[name]'
      })
      .end()
  }
}
```

最后在 `main.js` 中引入 `import '@/icons'` 即可。

## 封装 Axios

在 `src` 目录下创建 `utils`， 并创建 `axios.js` 用来封装 `axios`

```js
import axios from 'axios'

const service = axios.create({
  baseURL: process.env.BASE_URL,
  timeout: 10000
})
// request 拦截器
service.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers['Authorization'] = token
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)
// response 拦截器
service.interceptors.response.use(
  response => {
    const status = response.status
    if (status === 200) {
      return Promise.resolve(response.data)
    } else {
      return Promise.reject('error')
    }
  },
  error => {
    // 断网或请求超时
    if (!error.response) {
      if (error.message.includes('timeout')) {
        Message.error('请求超时，请检查网络是否连接正常')
      } else {
        Message.error('请求失败，请检查网络是否已连接')
      }
      return
    }

    const status = error.response.status
    switch (status) {
      // 未登录
      case 401:
        router.replace({
          path: '/login',
          query: {
            redirect: router.currentRoute.fullPath
          }
        })
        break
      // 登录过期
      case 403:
        Message({
          type: 'error',
          message: '登录信息过期，请重新登录'
        })

        localStorage.removeItem('token')
        setTimeout(() => {
          router.replace({
            path: '/login',
            query: {
              redirect: router.currentRoute.fullPath
            }
          })
        }, 1000)
        break
      // 请求错误
      case 404:
        Message({
          message: '网络请求错误',
          type: 'error'
        })
        break
      default:
        Message({
          message: error.response.data.message,
          type: 'error'
        })
    }
    return Promise.reject(error)
  }
)

export default service
```

既然要使用 `axios` ，必不可少的需要配置环境变量以及需要请求的地址，这里可以简单的修改 `poackage.json`

```json
"scripts": {
    "dev": "vue-cli-service serve --project-mode dev",
    "test": "vue-cli-service serve --project-mode test",
    "pro": "vue-cli-service serve --project-mode pro",
    "pre": "vue-cli-service serve --project-mode pre",
    "build:dev": "vue-cli-service build --project-mode dev",
    "build:test": "vue-cli-service build --project-mode test",
    "build:pro": "vue-cli-service build --project-mode pro",
    "build:pre": "vue-cli-service build --project-mode pre",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
```

同时修改 `vue.config.js`

```js
const path = require('path')

function resolve(dir) {
  return path.join(__dirname, './', dir)
}

module.exports = {
  chainWebpack: config => {
    // 配置BASE_API
    config.plugin('define').tap(args => {
      const argv = process.argv
      const mode = argv[argv.indexOf('--project-mode') + 1]
      args[0]['process.env'].MODE = `"${mode}"`
      args[0]['process.env'].BASE_URL = 'http://192.168.1.187:8080'
      // args[0]['process.env'].BASE_URL = JSON.stringify(process.env.BASE_URL)
      return args
    })
  }
}
```

这样的好处是方便管理、后期维护，还可以和后端的微服务对应，建立多文件存放不同模块的 `api`，剩下的就是你使用到哪个 `api` 时，自己引入便可。

## 全局 Loading

平时写网络请求之前一般都需要开启 `loading` 效果，成功之后结束 `loading` 效果，这就会产生大量重复代码，我们可以结合 `axios` 和 `vuex` 统一处理。

首先，在 `store/modules/app.js` 里写 `loading` 效果

```js
const app = {
  state: {
    requestLoading: 0
  },
  mutations: {
    SET_LOADING: (state, status) => {
      if (status === 0) {
        state.requestLoading = 0
        return
      }
      state.requestLoading = status ? ++state.requestLoading : --state.requestLoading
    }
  },
  actions: {
    SetLoading({ commit }, status) {
      commit('SET_LOADING', status)
    }
  }
}

export default app
```

再来修改一下 `utils/axios.js`

```js
import axios from 'axios'
import store from '@/store'

const service = axios.create({
  baseURL: process.env.BASE_URL,
  timeout: 10000
})
// request拦截器
service.interceptors.request.use(
  config => {
    store.dispatch('SetLoading', true)
    return config
  },
  error => {
    setTimeout(function() {
      store.dispatch('SetLoading', 0)
    }, 500)
    Promise.reject(error)
  }
)
// response拦截器
service.interceptors.response.use(
  response => {
    const res = response.data
    store.dispatch('SetLoading', false)
    return res
  },
  error => {
    store.dispatch('SetLoading', false)
    return Promise.reject(error)
  }
)

export default service
```

最后在 `src/components` 下创建 `RequestLoading.vue` 组件

```js
<template>
  <transition name="fade-transform" mode="out-in">
    <div class="request-loading-component" v-if="requestLoading">
      <svg-icon icon-class="loading" />
    </div>
  </transition>
</template>

<script>
import { mapGetters } from 'vuex'

export default {
  name: 'RequestLoading',
  computed: {
    ...mapGetters([
      'requestLoading'
    ])
  }
}
</script>

```

## CDN 优化

首先在 `vue.config.js` 里进行配置

```js
const path = require('path')

function resolve(dir) {
  return path.join(__dirname, './', dir)
}
module.exports = {
  chainWebpack: config => {
    const externals = {
      'vue': 'Vue',
      'vuex': 'Vuex',
      'vue-router': 'VueRouter'，
      'axios': 'axios',
      'js-cookie': 'Cookies'，
      'nprogress': 'NProgress',
      'element-ui': 'ELEMENT'
    }
    const cdn = {
      dev: {
        css: [
          'https://unpkg.com/element-ui/lib/theme-chalk/index.css',
          'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
        ],
        js: []
      },
      build: {
        css: [
          'https://unpkg.com/element-ui/lib/theme-chalk/index.css',
          'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css'
        ],
        js: [
          'https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js',
          'https://cdn.jsdelivr.net/npm/vuex@3.0.1/dist/vuex.min.js',
          'https://cdn.jsdelivr.net/npm/vue-router@3.0.1/dist/vue-router.min.js',
          'https://cdn.jsdelivr.net/npm/axios@0.18.0/dist/axios.min.js',
          'https://cdn.bootcss.com/js-cookie/2.2.0/js.cookie.min.js',
          'https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js',
          'https://unpkg.com/element-ui/lib/index.js'
        ]
      }
    }

    // 配置CDN
    config.plugin('html').tap(args => {
      if (process.env.NODE_ENV === 'production') {
        args[0].cdn = cdn.build
      } else {
        args[0].cdn = cdn.dev
      }
      return args
    })
  },

  configureWebpack: config => {
    if (process.env.NODE_ENV === 'production') {
      // 生产环境NPM包转CDN
      config.externals = externals
    } else {
      // 开发环境关闭HostCheck，方便使用内网转发工具
      config.devServer = {
        disableHostCheck: true
      }
    }
  }
}
```

然后去 `index.html` 里添加引用标签

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="icon" href="<%= BASE_URL %>favicon.ico" />

    <!-- 引用CSS文件 -->
    <% for (var css of htmlWebpackPlugin.options.cdn.css) { %>
    <link href="<%=css%>" rel="preload" as="style" />
    <link href="<%=css%>" rel="stylesheet" as="style" />
    <% } %>

    <!-- 引用JS文件 -->
    <% for (var js of htmlWebpackPlugin.options.cdn.js) { %>
    <link href="<%=js%>" rel="preload" as="script" />
    <script src="<%=js%>"></script>
    <% } %>

    <title>vue-project-demo</title>
  </head>

  <body>
    <noscript>
      <strong
        >We're sorry but vue-project-demo doesn't work properly without JavaScript enabled. Please enable it to
        continue.</strong
      >
    </noscript>
    <div id="app"></div>

    <!-- 引用JS文件 -->
    <% for (var js of htmlWebpackPlugin.options.cdn.js) { %>
    <script src="<%=js%>"></script>
    <% } %>
  </body>
</html>
```

## Gzip 压缩

首先安装插件 `compression-webpack-plugin` ，修改 `vue.config.js`

```js
const path = require('path')
const CompressionWebpackPlugin = require('compression-webpack-plugin')

function resolve(dir) {
  return path.join(__dirname, './', dir)
}

// 是否使用gzip
const productionGzip = true
// 需要gzip压缩的文件后缀
const productionGzipExtensions = ['js', 'css']

module.exports = {
  chainWebpack: config => {
    if (process.env.NODE_ENV === 'production') {
      // 配置GZIP
      config
        .plugin('compression')
        .use(CompressionPlugin, {
          asset: '[path].gz[query]',
          algorithm: 'gzip',
          test: new RegExp('\\.(' + ['js', 'css'].join('|') + ')$'),
          threshold: 10240,
          minRatio: 0.8,
          cache: true
        })
        .tap(args => {})
    }
  }
}
```

打包后我们会发现 `dist` 下所有的 `js` 文件和 `css` 文件都会多出一个 `.gz` 文件，这就是我们需要的压缩文件。如果服务端使用的是 `nginx` 服务器的话，需要配置开启 `gzip` 才能支持

```nginx
gzip on;
gzip_static on;
gzip_min_length 1024;
gzip_buffers 4 16k;
gzip_comp_level 2;
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;
gzip_vary off;
gzip_disable "MSIE [1-6]\.";
```

配置完重启服务器即可生效。
